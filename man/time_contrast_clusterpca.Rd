% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/time_contrast_clusterpca.R
\name{time_contrast_clusterpca}
\alias{time_contrast_clusterpca}
\title{Time-contrast cluster PCA (sample-space generalized PCA with background)}
\usage{
time_contrast_clusterpca(
  X,
  clus,
  ncomp = 3L,
  scheme = list(type = "uniform", sigma = NULL, k = 32L, rings = NULL, phi = "abs"),
  distmat = NULL,
  q_bg = NULL,
  tau = NULL,
  center_time = TRUE,
  mode = c("whiten", "partial", "contrastive"),
  alpha = NULL,
  alpha_grid = 10^seq(-2, 2, length.out = 7L),
  ridge_bg = 0.01,
  svd_method = c("irlba", "svd"),
  verbose = FALSE
)
}
\arguments{
\item{X}{Numeric matrix (T x P): rows are timepoints/samples, columns are voxels/features.}

\item{clus}{Integer/factor of length P assigning each column to a cluster (K clusters).}

\item{ncomp}{Integer (>=1), number of components per cluster (can be a scalar or length-K vector).}

\item{scheme}{List describing how to weight background clusters. Basic fields:
\itemize{
\item \code{type}: one of \code{"uniform"}, \code{"gaussian"}, \code{"knn_near"}, \code{"knn_far"},
\code{"rings"}, \code{"similarity"}.
\item \code{sigma}: bandwidth for \code{"gaussian"} (on distances between clusters).
\item \code{k}: number of neighbors for \code{"knn_*"}.
\item \code{rings}: numeric vector of distance breakpoints for \code{"rings"}.
Note: The method gives uniform weight to all background clusters in the
outermost ring (most distant from target) and zero weight to all others.
Example: \code{c(5, 15)} creates rings at distances 0-5, 5-15, >15.
\item \code{phi}: for \code{"similarity"}, how to convert correlation to weights; one of
\code{"abs"}, \code{"pos"}, \code{"neg"}.
}
Missing fields fall back to sensible defaults.}

\item{distmat}{Optional (K x K) matrix of nonnegative distances between clusters (e.g., centroids).
Required for distance-based schemes (\code{"gaussian"}, \code{"knn_*"}, \code{"rings"}).}

\item{q_bg}{Optional integer; if set, truncate the background rank to \code{q_bg} (top modes of \eqn{L_C}).}

\item{tau}{Nonnegative ridge added to \eqn{B_C}; default is data-driven (small fraction of background energy).}

\item{center_time}{Logical; if TRUE (default) center each column (voxel) over time before fitting.}

\item{mode}{Engine: \code{"whiten"} (generalized PCA via background whitener),
\code{"partial"} (residualize cluster on background means w/ ridge),
or \code{"contrastive"} (cPCA: eigen of A_C - alpha B_C).}

\item{alpha}{Contrastive strength for \code{mode="contrastive"}.
If \code{NULL}, uses \code{alpha_grid} to auto-select.}

\item{alpha_grid}{Optional numeric vector of candidate alphas for auto-selection (default: 10^seq(-2,2,length=7)).}

\item{ridge_bg}{Ridge parameter for background regression in \code{mode="partial"} (default: 1e-2).}

\item{svd_method}{SVD backend when decomposing \eqn{Y_C}: \code{"irlba"} (default) or \code{"svd"}.}

\item{verbose}{Logical; print per-cluster progress.}
}
\value{
An object of class \code{c("time_contrast_clusterpca","clusterpca")}, with:
\itemize{
\item \code{clus}: factor of cluster assignments for columns.
\item \code{clusters}: cluster labels (levels).
\item \code{indices}: list of column indices per cluster.
\item \code{fits}: list per cluster with fields:
\code{u} (T x r), \code{v} (|C| x r), \code{d} (length r),
\code{bg} whitener parameters (\code{U}, \code{s}, \code{tau}),
and \code{time_scores} (T x r).
\item \code{scheme}, \code{q_bg}, \code{tau}, \code{ncomp}: config
\item \code{dims}: list with \code{T}, \code{P}, \code{K}.
}
}
\description{
For each cluster of columns (voxels), compute a PCA in \emph{time/sample} space
that emphasizes variance in that cluster while downweighting variance captured
by a \emph{background} built from the \emph{mean time-series of other clusters}.
The background can be weighted (e.g., by spatial distance or similarity) and
is handled efficiently via a low-rank whitener:
\deqn{B_C = L_C L_C^\top + \tau I,\quad L_C = [\sqrt{w_k}(m_k - \mu^{(C)})]_{k\ne C}}
so that we whiten the data as \eqn{Y_C = (B_C)^{-1/2} X_C} and perform a thin SVD.
}
\details{
The method constructs a low-rank background for each cluster C using the mean
time-series of the \emph{other} clusters. Weighting schemes let you emphasize
near vs. far clusters, rings/annuli, or time-course similarity.

Projection to new data uses the stored whitener (\eqn{U,s,\tau}) and voxel
loadings (\code{v}) to compute time scores in the same contrastive subspace.
}
\examples{
\dontrun{
set.seed(1)
T <- 200; P <- 1000; K <- 50
clus <- sample(1:K, P, replace=TRUE)
X <- matrix(rnorm(T*P), T, P)
# Fake cluster centroid distances (for demo only)
distmat <- as.matrix(stats::dist(matrix(rnorm(K*3), K, 3)))
fit <- time_contrast_clusterpca(
  X, clus, ncomp=3,
  scheme=list(type="gaussian", sigma=median(distmat)),
  distmat=distmat, q_bg=20, verbose=TRUE
)
dim(scores(fit))  # T x sum(ncomp)
dim(coef(fit))    # P x sum(ncomp)
}

}
