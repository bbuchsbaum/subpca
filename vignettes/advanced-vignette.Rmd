---
title: "Advanced Topics in subpca"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced Topics in subpca}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  message = FALSE,
  warning = FALSE
)
```

```{r setup}
library(subpca)
library(multivarious)
library(Matrix)
library(future)
library(microbenchmark)
```

## Overview

This vignette covers advanced topics in the subpca package:

- Understanding meta-PCA concepts
- Performance optimization strategies
- Custom PCA implementations
- Handling large-scale data
- Method comparisons and selection
- Integration with other packages

## Meta-PCA: The Core Concept

The `metapca()` function is the foundation for combining multiple PCA fits:

```{r metapca-basics}
set.seed(999)

# Create separate datasets
X1 <- matrix(rnorm(100 * 20), 100, 20)
X2 <- matrix(rnorm(100 * 30), 100, 30)
X3 <- matrix(rnorm(100 * 25), 100, 25)

# Perform individual PCAs
pca1 <- pca(X1, ncomp = 5, preproc = center())
pca2 <- pca(X2, ncomp = 5, preproc = center())
pca3 <- pca(X3, ncomp = 5, preproc = center())

# Combine with meta-PCA
fits <- list(pca1, pca2, pca3)
meta_result <- metapca(fits, ncomp = 10)

cat("Meta-PCA dimensions:\n")
cat("Scores:", dim(scores(meta_result)), "\n")
cat("Loadings:", dim(components(meta_result)), "\n")
```

## Meta-PCA Weighting Strategies

Different weighting strategies affect how blocks are combined:

```{r metapca-weighting}
# Equal weighting (default)
meta_equal <- metapca(fits, ncomp = 8, combine = "pca")

# Scaled by standard deviation
meta_scaled <- metapca(fits, ncomp = 8, combine = "scaled")

# MFA-style (weighted by first eigenvalue)
meta_mfa <- metapca(fits, ncomp = 8, combine = "MFA")

# Custom weights based on block importance
custom_weights <- c(1, 3, 2)  # Weight second block more
meta_weighted <- metapca(fits, ncomp = 8, weights = custom_weights)

# Compare first components
scores_equal <- scores(meta_equal)[, 1]
scores_scaled <- scores(meta_scaled)[, 1]
scores_mfa <- scores(meta_mfa)[, 1]
scores_weighted <- scores(meta_weighted)[, 1]

cor_matrix <- cor(cbind(scores_equal, scores_scaled, scores_mfa, scores_weighted))
colnames(cor_matrix) <- rownames(cor_matrix) <- 
  c("Equal", "Scaled", "MFA", "Weighted")

cat("Correlation between weighting methods:\n")
print(round(cor_matrix, 3))
```

## Block-wise Projection

Project new data block by block:

```{r blockwise-projection}
# New data for each block (must match original dimensions)
X1_new <- matrix(rnorm(10 * 20), 10, 20)
X2_new <- matrix(rnorm(10 * 30), 10, 30)
X3_new <- matrix(rnorm(10 * 25), 10, 25)

# Full projection
X_new_full <- cbind(X1_new, X2_new, X3_new)
scores_full <- project(meta_result, X_new_full)

cat("Full projection dimensions:", dim(scores_full), "\n")

# Partial projection (specific columns)
# First 10 columns from block 1, columns 21-30 from block 2
col_indices <- c(1:10, 21:30)  
X_partial <- X_new_full[, col_indices]
scores_partial <- partial_project(meta_result, X_partial, colind = col_indices)
cat("Partial projection dimensions:", dim(scores_partial), "\n")

# Note: project_block function requires exact match of block structure
# which may not be available in all metapca configurations
```

## Performance Optimization

### Parallel Processing

```{r parallel-optimization}
# Set up parallel backend
plan(multisession, workers = 2)

# Large dataset for benchmarking
X_large <- matrix(rnorm(500 * 200), 500, 200)
clus_large <- rep(1:20, each = 10)

# Benchmark parallel vs sequential
bench_results <- microbenchmark(
  sequential = {
    plan(sequential)
    clusterpca(X_large, clus_large, ccomp = 2)
  },
  parallel = {
    plan(multisession, workers = 2)
    clusterpca(X_large, clus_large, ccomp = 2)
  },
  times = 3
)

print(bench_results)
plan(sequential)  # Reset to sequential
```

### Memory-Efficient Sparse Representations

```{r sparse-efficiency}
# Create highly structured sparse data
n_obs <- 200
n_vars <- 500
n_clusters <- 50

X_sparse_base <- matrix(0, n_obs, n_vars)
# Add signals to specific cluster regions
for(i in 1:n_clusters) {
  var_idx <- ((i-1)*10 + 1):(i*10)
  if(i %% 5 == 0) {  # Every 5th cluster has signal
    X_sparse_base[, var_idx] <- rnorm(n_obs * 10)
  }
}

clus_sparse <- rep(1:n_clusters, each = 10)

# Run clusterpca
result_sparse <- clusterpca(X_sparse_base, clus_sparse, 
                           ccomp = 1, colwise = TRUE)

# Check sparsity of loadings
loadings_sparse <- coef(result_sparse)
sparsity <- 1 - nnzero(loadings_sparse)/(nrow(loadings_sparse) * ncol(loadings_sparse))
cat("Loadings sparsity:", round(sparsity * 100, 2), "%\n")

# Memory comparison
cat("Dense matrix size:", object.size(as.matrix(loadings_sparse)), "bytes\n")
cat("Sparse matrix size:", object.size(loadings_sparse), "bytes\n")
```

## Custom PCA Implementations

Create specialized PCA functions for specific needs:

```{r custom-implementations}
# Robust PCA using Huber loss
robust_pca <- function(X, ncomp, preproc, ind = NULL) {
  # Simple robust centering using median
  X_robust <- sweep(X, 2, apply(X, 2, median), "-")
  
  # Use MAD for scaling
  mads <- apply(X_robust, 2, mad)
  mads[mads == 0] <- 1  # Avoid division by zero
  X_robust <- sweep(X_robust, 2, mads, "/")
  
  # Standard PCA on robust-preprocessed data
  multivarious::pca(X_robust, ncomp = ncomp, preproc = pass())
}

# Sparse PCA (simplified version)
sparse_pca <- function(X, ncomp, preproc, ind = NULL) {
  X_processed <- init_transform(preproc, X)
  
  # Standard PCA first
  pca_result <- multivarious::pca(X_processed, ncomp = ncomp, preproc = pass())
  
  # Apply soft thresholding to loadings
  v <- components(pca_result)
  threshold <- 0.1 * max(abs(v))
  v[abs(v) < threshold] <- 0
  
  # Recreate bi_projector with sparse loadings
  # Note: This is simplified - real sparse PCA is more complex
  s <- X_processed %*% v
  
  bi_projector(
    v = v,
    s = s,
    sdev = apply(s, 2, sd),
    preproc = preproc,
    classes = "pca"
  )
}

# Test custom implementations
X_test <- matrix(rnorm(100 * 50), 100, 50)
X_test[1:5, ] <- X_test[1:5, ] + 10  # Add outliers
clus_test <- rep(1:5, each = 10)

result_robust <- clusterpca(X_test, clus_test, ccomp = 2, 
                           pcafun = robust_pca)
result_sparse <- clusterpca(X_test, clus_test, ccomp = 2,
                           pcafun = sparse_pca)

cat("Custom PCA implementations applied successfully\n")
```

## Handling Missing Data

Strategies for dealing with missing values:

```{r missing-data}
# Create data with missing values
X_missing <- matrix(rnorm(100 * 40), 100, 40)
missing_idx <- sample(length(X_missing), size = 100)
X_missing[missing_idx] <- NA

# Strategy 1: Simple imputation before analysis
X_imputed <- X_missing
for(j in 1:ncol(X_imputed)) {
  col_mean <- mean(X_imputed[, j], na.rm = TRUE)
  X_imputed[is.na(X_imputed[, j]), j] <- col_mean
}

clus <- rep(1:4, each = 10)

# Run subpca on imputed data
result_imputed <- subpca(X_imputed, clus, ncomp = 5, ccomp = 2)

cat("Analysis with imputed data completed\n")
cat("Result dimensions:", dim(scores(result_imputed)), "\n")
```

## Method Comparison Framework

Compare different approaches systematically:

```{r method-comparison}
# Generate structured test data
set.seed(777)
n <- 150
p <- 60

# True underlying structure
latent <- matrix(rnorm(n * 3), n, 3)  # 3 true components
loadings_true <- matrix(rnorm(p * 3), p, 3)
X_true <- latent %*% t(loadings_true)
X_observed <- X_true + matrix(rnorm(n * p, sd = 0.5), n, p)  # Add noise

# Define clusters
clus <- rep(1:6, each = 10)

# Compare methods
methods <- list(
  standard_pca = function(X) {
    pca(X, ncomp = 5, preproc = center())
  },
  subpca_default = function(X) {
    subpca(X, clus, ncomp = 5, ccomp = 2)
  },
  subpca_weighted = function(X) {
    weights <- c(2, 1, 1, 1, 1, 2)  # Weight first and last clusters
    subpca(X, clus, ncomp = 5, ccomp = 2, weights = weights)
  },
  clusterpca_only = function(X) {
    fit <- clusterpca(X, clus, ccomp = 2)
    # Create pseudo bi_projector for comparison
    list(scores = scores(fit), components = components(fit))
  }
)

# Evaluate reconstruction error for each method
reconstruction_errors <- numeric(length(methods))
names(reconstruction_errors) <- names(methods)

for(i in seq_along(methods)) {
  if(names(methods)[i] == "clusterpca_only") {
    # Special handling for clusterpca
    result <- methods[[i]](X_observed)
    X_recon <- result$scores %*% t(result$components)
  } else {
    result <- methods[[i]](X_observed)
    X_recon <- reconstruct(result, comp = 1:5)
  }
  
  reconstruction_errors[i] <- sum((X_observed - X_recon)^2) / sum(X_observed^2)
}

# Display comparison
barplot(reconstruction_errors,
        main = "Reconstruction Error Comparison",
        ylab = "Relative Error",
        col = rainbow(length(methods)),
        las = 2)
```

## Advanced Preprocessing Pipelines

Create complex preprocessing workflows:

```{r advanced-preprocessing}
# Custom preprocessing pipeline
library(magrittr)

# Pipeline 1: Center, scale, then whiten
preproc_whiten <- function() {
  pre_processor(
    input_dim = NA,
    output_dim = NA,
    
    transform = function(x, object) {
      x <- scale(x, center = TRUE, scale = TRUE)
      # Simple whitening
      cov_mat <- cov(x)
      eigen_decomp <- eigen(cov_mat)
      whitening_matrix <- eigen_decomp$vectors %*% 
                         diag(1/sqrt(eigen_decomp$values + 1e-8)) %*% 
                         t(eigen_decomp$vectors)
      x %*% whitening_matrix
    },
    
    inverse_transform = function(x, object) {
      # Simplified - real inverse would need stored parameters
      x
    }
  )
}

# Pipeline 2: Robust standardization
preproc_robust <- function() {
  pre_processor(
    input_dim = NA,
    output_dim = NA,
    
    transform = function(x, object) {
      # Use median and MAD instead of mean and SD
      medians <- apply(x, 2, median)
      mads <- apply(x, 2, mad)
      mads[mads == 0] <- 1
      
      sweep(sweep(x, 2, medians, "-"), 2, mads, "/")
    },
    
    inverse_transform = function(x, object) {
      x
    }
  )
}

# Note: These custom preprocessors are simplified examples
# The full implementation would need proper parameter storage
```

## Diagnostic Tools

Create diagnostic functions for model evaluation:

```{r diagnostics}
# Diagnostic function for subpca results
diagnose_subpca <- function(result, X_original, clus) {
  cat("=== SUBPCA DIAGNOSTIC REPORT ===\n\n")
  
  # 1. Basic info
  cat("Data dimensions:", dim(X_original), "\n")
  cat("Number of clusters:", length(unique(clus)), "\n")
  cat("Final components:", ncomp(result), "\n\n")
  
  # 2. Variance explained
  sdev_vals <- sdev(result)
  var_explained <- sdev_vals^2 / sum(sdev_vals^2)
  cumvar <- cumsum(var_explained)
  
  cat("Variance explained by component:\n")
  for(i in 1:min(5, length(var_explained))) {
    cat(sprintf("  PC%d: %.1f%% (cumulative: %.1f%%)\n", 
                i, var_explained[i]*100, cumvar[i]*100))
  }
  cat("\n")
  
  # 3. Reconstruction quality
  X_recon <- reconstruct(result)
  recon_error <- sum((X_original - X_recon)^2) / sum(X_original^2)
  cat("Reconstruction error:", round(recon_error, 4), "\n\n")
  
  # 4. Cluster contribution
  loadings <- components(result)
  cluster_contrib <- matrix(0, length(unique(clus)), ncol(loadings))
  
  for(i in unique(clus)) {
    cluster_vars <- which(clus == i)
    cluster_contrib[i, ] <- colSums(abs(loadings[cluster_vars, , drop = FALSE]))
  }
  
  cat("Cluster contributions to first 3 components:\n")
  print(round(cluster_contrib[, 1:min(3, ncol(cluster_contrib))], 3))
  cat("\n")
  
  # 5. Component orthogonality
  scores_mat <- scores(result)
  cor_mat <- cor(scores_mat)
  off_diag <- cor_mat[upper.tri(cor_mat)]
  
  cat("Component orthogonality check:\n")
  cat("  Max off-diagonal correlation:", round(max(abs(off_diag)), 4), "\n")
  cat("  Mean absolute off-diagonal:", round(mean(abs(off_diag)), 4), "\n")
  
  invisible(list(
    var_explained = var_explained,
    recon_error = recon_error,
    cluster_contrib = cluster_contrib
  ))
}

# Test the diagnostic function
X_diag <- matrix(rnorm(100 * 40), 100, 40)
clus_diag <- rep(1:4, each = 10)
result_diag <- subpca(X_diag, clus_diag, ncomp = 5, ccomp = 2)

diag_report <- diagnose_subpca(result_diag, X_diag, clus_diag)
```

## Integration with Other Packages

### With FactoMineR

```{r factominer-integration, eval=FALSE}
# Example integration with FactoMineR (not run)
library(FactoMineR)

# Use subpca for initial dimension reduction
result_subpca <- subpca(X, clus, ncomp = 10, ccomp = 3)
scores_reduced <- scores(result_subpca)

# Further analysis with FactoMineR
mfa_result <- MFA(scores_reduced, 
                  group = c(3, 3, 4),  # Group the 10 components
                  type = rep("s", 3))  # All quantitative

# Visualize with FactoMineR tools
plot(mfa_result, choix = "ind")
```

### With tidymodels

```{r tidymodels-integration, eval=FALSE}
# Example integration with tidymodels (not run)
library(tidymodels)
library(recipes)

# Create a recipe step for subpca
step_subpca <- function(recipe, ..., clus, ncomp = 5, ccomp = 2) {
  # Custom step implementation would go here
  # This is a conceptual example
}

# Use in a modeling workflow
rec <- recipe(outcome ~ ., data = training_data) %>%
  step_subpca(all_predictors(), 
              clus = predictor_clusters,
              ncomp = 10, 
              ccomp = 3) %>%
  step_normalize(all_predictors())
```

## Best Practices Summary

1. **Choose the right method**:
   - `subpca()`: General hierarchical PCA with known clusters
   - `clusterpca()`: When you only need cluster-level PCA
   - `hcluspca()`: When clusters should be learned from data
   - `musubpca()`: For multi-block/multi-view data

2. **Optimize performance**:
   - Use parallel processing for large datasets
   - Consider sparse representations for high-dimensional data
   - Profile code to identify bottlenecks

3. **Validate results**:
   - Check reconstruction error
   - Examine variance explained
   - Verify component orthogonality
   - Assess cluster contributions

4. **Handle edge cases**:
   - Missing data: Impute before analysis
   - Outliers: Use robust PCA variants
   - High dimensions: Consider sparse PCA

5. **Document and reproduce**:
   - Set seeds for reproducibility
   - Document preprocessing choices
   - Save diagnostic reports

## Conclusion

The subpca package provides a flexible framework for hierarchical PCA that can be adapted to various data structures and analysis needs. By understanding these advanced concepts and techniques, you can:

- Choose appropriate methods for your data
- Optimize performance for large-scale analyses
- Create custom solutions for specific requirements
- Integrate with other analytical workflows
- Diagnose and validate your results

For specific use cases, refer to the other vignettes in this package:
- `vignette("intro-subpca")`: Basic usage
- `vignette("clusterpca-vignette")`: Cluster-wise PCA
- `vignette("hcluspca-vignette")`: Hierarchical clustering PCA  
- `vignette("musubpca-vignette")`: Multi-block analysis